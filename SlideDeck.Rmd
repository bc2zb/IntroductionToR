---
title: "Introduction to R: A Computational Workbench for Biological Data Analysis"
author: "Brian Capaldo"
date: "6/10/2017"
output: slidy_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Acknowledgements

- [May Institute](https://computationalproteomics.ccis.northeastern.edu/)

  - [GitHub](https://github.com/MayInstitute/MayInstitute2017)
  
- Association of Biomolecular Research Facilities

- International Society for Advancement of Cytometry

- The Bioconductor Project

- UVA Office of Research Core Administration
  
## Why R?

- It's flexible (this presentation was made using R)

- It's open source

- It's widely supported

## History of R

- The R programming language has its roots in S, a language created forty years ago at ATT Bell Labs by Chambers, Becker and Wilks.

- The motivation for S was to simplify the task of calling statistical routines written in FORTRAN (this involved writing code to read in, format and write out the data).

- The goal of S was to free users of the drudgery of writing that interface code and speed up the data analystâ€™s workflow. The key linguistic design principle was to design a language that could be extended and that was devoid of arbitrary limitations.

- The S language was such a success that users started writing statistical routines in S.

- The R programming language was designed by Ross Ihaka and Robert Gentleman at the University of Auckland around 1992.

- R departed from S in number of ways, it was an open source language released under a GPL license to ensure that everything related to R remains in the public domain, R cleaned up some corners of S and improve the performance of programs written in the language.

## R as a computational bench top 

- Data as experiments
- Data structures as glassware
- Functions as instruments
- Vignettes as protocols

## Data types in R

The base types include `double`, `integer`, `characater` and `logical`.  Values can be tested as belonging to one of those types.

##

```{r, echo = TRUE}
typeof(1)
```

##

```{r, echo = TRUE}
typeof(1L)
```

##

```{r, echo = TRUE}
is.numeric(1.1)
```

##

```{r, echo = TRUE}
is.logical(TRUE)
is.character("Hello")
```


## Vectors

R provides several kinds of compound data structures commonly referred to as *vectors*.  All operations in R are *vectorized*, this means that they take vectors as arguments and they will operate on the individual values (basic types) of these vectors.

The operator `[<-` is the assignment function.

```{r, echo = TRUE}
x <- c(1,2,2)   # 'c()' is the concatenate function
y <- c(2,2,1)   
( x + y ) * x
```

## Atomic vectors

Atomic vectors are homogeneous (possibly multi-dimensional) data structures.

```{r, echo = TRUE}
c(1,2,3)                # again using 'c()' to concatenate
c("one","two","three")
```

## Subsetting

All vectors can be accessed used subsetting operators `[` and `[[`
- `typeof()` 
    - to find out what basic type is in the vector
- `length()`
    - how many elements are in it
- `attributes()` 
    - query the vector's meta data

## Element of vectors can be accessed individually.

```{r, echo = TRUE}
x <- c(1L, 2L, 3L) # The `L` lets R know you want an interger
x[1] <- 45
x[1]
```

## A two dimensional atomic vector is called a *matrix* and higher-dimensional vector is called an *array*.

```{r, echo = TRUE}
a <- matrix(1:6, ncol = 3, nrow = 2)
b <- array(1:12, c(2,3,4))
```

## a

a <- matrix(1:6, ncol = 3, nrow = 2)

```{r, echo = TRUE}
a
```

## b

b <- array(1:12, c(2,3,4))

```{r, echo = TRUE}
b
```

## Dynamic typing and coercions 

Matrices and array, like vectors, are homogeneous, but it is possible to assign values of different basic types into any one of them. This causes a *coercion* of the entire data structure.

```{r, echo = TRUE}
x
x[[1]] <-1.1
x
```

##

```{r, echo=T}
a
a[[2,1]] <- "one"
a
```

## R has a powerful set of subsetting operations that apply to all vectors uniformly. R allows, to subset ranges, rows, columns of vectors.

```{r, echo = TRUE}
a[1,]       # subset the first row
a[1:2,]     # subset a range consisting of the first and second row
a[1:2,2:3]  # subset a range consisting of the first and second row and the second and third column
```

## Coercions

```{r, echo = TRUE}
aa <- as.integer(a) # as.___ functions coerce one type into another
a
aa
```

##

```{r, echo = TRUE}
aa
dim(aa) <- c(2,3) # dim() refers to the dimension of the data structure
aa
a[1, a[1,] > 1] # here we are subsetting the first row of a and returning which positions are > 1
aa[1, aa[1,] > 1]
```

## When using a predicate such as `a[1,] > 1` for subsetting, behind the scenes R generates a vector of logical values. True indicates a position that should be extracted.  So this is:

```{r, echo = TRUE}
aa[1,]>1
```

## We can use logical arrays to subset as follows:

```{r, echo = TRUE}
aa[1, c(FALSE, TRUE, TRUE)]
```

## Subsetting can be used in assignment operations as well.

```{r, echo = TRUE}
a
a[1:3] <- a[4:6]
a
```


## Lists

Lists are heterogeneous vectors. The elements of list can be of any kind, including lists and vectors.

```{r, echo = TRUE}
list(1, "hi", c(1,2))
```

The `typeof()` a list is `list`. You can test for a list with `is.list()` and coerce to a list with `as.list()`. You can turn a list into an atomic vector with `unlist()`. If the elements of a list have different types, `unlist()` will coerce.

## Referential transparency

To facilitate equational reasoning, R attempts to provide *referential transparency* for function calls. Referential transparency means that arguments are not changed by the function being called. So the following function `f(x)` does not modify the vector passed in.

```{r, echo = TRUE}
x
f <- function(x) { x[1] <- 1 }
f(x)
x
```

## Questions on the basics of R?

## Packages

- In R, collections of data, functions, and compiled code are stored as *packages*. *Packages* can be thought of as the computational benchtop equivalent of the reagents and instruments required to perfrom a specific computational assay. 

- There are two primary repositories from which to get *packages*, [CRAN](https://cran.r-project.org/) and [Bioconductor](http://bioconductor.org/)

- Bioconductor has made available a number of previous [courses](http://bioconductor.org/help/course-materials/) as well

## Installing packages from CRAN

```{r, echo=TRUE}
install.packages("tidyverse", verbose = T, repos='http://cran.us.r-project.org')
```

## Installing packages from Bioconductor

```{r, echo =T}
source("https://bioconductor.org/biocLite.R")
biocLite("flowCore", verbose = T, suppressUpdates = T)
```

## Loading libraries

```{r, echo = T}
library(flowCore)
library(tidyverse)
```



## ----ReadFiles
```{r, echo = T}
file.name <- system.file("extdata","0877408774.B08", package="flowCore")
x <- read.FCS(file.name, transformation=FALSE)
summary(x)
```
## ----SearchKeywords
```{r, echo = T}
keyword(x,c("$P1E", "$P2E", "$P3E", "$P4E"))
```
## ----PrintSummary
```{r, echo = T}
summary(read.FCS(file.name))
```
## ----PrintSummary2

```{r, echo = T}
summary(read.FCS(file.name,transformation="scale")) 
```

## ----ReadFiles2
```{r, echo = T}
read.FCS(file.name,alter.names=TRUE) 
```
## ----RedFiles3
```{r, echo = T}
x <- read.FCS(file.name, column.pattern="-H") 
x 
```
## ----RedFiles4
```{r, echo = T}
lines <- sample(100:500, 50)
y <- read.FCS(file.name, which.lines = lines) 
y 
```

## ----Plot2
```{r, echo = T}
library(ggcyto)
autoplot(x, "FL1-H", "FL2-H")
```
## ----plot3
```{r, echo = T}
autoplot(x, "FL1-H")
```
## ----Frames1
```{r, echo = T}
frames <- lapply(dir(system.file("extdata", "compdata", "data",
                           package="flowCore"), full.names=TRUE), 
                 read.FCS)
as(frames, "flowSet")
```
## ----Frames2
```{r, echo = T}
names(frames) <- sapply(frames, keyword, "SAMPLE ID")
fs <- as(frames, "flowSet")
fs
```
## ----metaData
```{r, echo = T}
phenoData(fs)$Filename <- fsApply(fs,keyword, "$FIL")
pData(phenoData(fs))
```
## ----ReadFlowSet
```{r, echo = T}
read.flowSet(path = system.file("extdata", "compdata", "data", 
             package="flowCore"))
```
## ----ReadFowSet2
```{r, echo = T}
fs <- read.flowSet(path=system.file("extdata", "compdata", "data",
                   package="flowCore"), name.keyword="SAMPLE ID",
                   phenoData=list(name="SAMPLE ID", Filename="$FIL"))
fs
pData(phenoData(fs))
```
## ----fsApply1
```{r, echo = T}
fsApply(fs, each_col, median)
```
## ----fsApply2
```{r, echo = T}
fsApply(fs,function(x) apply(x, 2, median), use.exprs=TRUE)
```
## ----Transfo1
```{r, echo = T}
autoplot(transform(fs[[1]]
                   , `FL1-H`=log(`FL1-H`)
                   , `FL2-H`=log(`FL2-H`)
                   )
         , "FL1-H","FL2-H")
```
## ----Transfo2
```{r, echo = T}
autoplot(transform(fs[[1]]
                   , log.FL1.H=log(`FL1-H`)
                   , log.FL2.H=log(`FL2-H`)
                   )
         , "log.FL1.H", "log.FL2.H")
```
## ----Transfo3
```{r, echo = T}
aTrans <- truncateTransform("truncate at 1", a=1)
aTrans
```
## ----Transfo4
```{r, echo = T}
transform(fs,`FL1-H`=aTrans(`FL1-H`))
```
## ----Transfo4.1
```{r, echo = T}
f1 <- function(fs,...){
  transform(fs, ...)[,'FL1-H']
}

f2 <- function(fs){
  aTrans <- truncateTransform("truncate at 1", a=1)
  f1(fs, `FL1-H` = aTrans(`FL1-H`))
}
res <- try(f2(fs), silent = TRUE)
res
```
## ----Transfo4.2
```{r, echo = T}
myTrans <- transformList('FL1-H', aTrans)
transform(fs, myTrans)
```
## ----rectGate
```{r, echo = T}
rectGate <- rectangleGate(filterId="Fluorescence Region", 
                          "FL1-H"=c(0, 12), "FL2-H"=c(0, 12))
```
## 
```{r, echo = T}
result = filter(fs[[1]],rectGate)
result
```
## ----Summary3
```{r, echo = T}
summary(result)
summary(result)$n
summary(result)$true
summary(result)$p
```
## ----SummarFilter
```{r, echo = T}
summary(filter(fs[[1]], kmeansFilter("FSC-H"=c("Low", "Medium", "High"),
                                     filterId="myKMeans")))
```
## 
```{r, echo = T}
filter(fs,rectGate)
```
## ----Norm2Filter
```{r, echo = T}
morphGate <- norm2Filter("FSC-H", "SSC-H", filterId="MorphologyGate", 
                         scale=2)
smaller <- Subset(fs, morphGate)
fs[[1]]
smaller[[1]]
```
## ----Split
```{r, echo = T}
split(smaller[[1]], kmeansFilter("FSC-H"=c("Low","Medium","High"),
                                 filterId="myKMeans"))
```
## ----Split2
```{r, echo = T}
split(smaller, kmeansFilter("FSC-H"=c("Low", "Medium", "High"),
                            filterId="myKMeans"))
```
## ----CombineFilter
```{r, echo = T}
rectGate & morphGate
rectGate | morphGate
!morphGate
```

## ----Summary5
```{r, echo = T}
summary(filter(smaller[[1]],rectGate %&% morphGate))
```
## ----Transfo5
```{r, echo = T}
tFilter <- transform("FL1-H"=log,"FL2-H"=log)
tFilter
```
## ----TectGate3
```{r, echo = T}
rect2 <- rectangleGate(filterId="Another Rect", "FL1-H"=c(1,2), 
"FL2-H"=c(2,3)) %on% tFilter
rect2
```
## ----Plot6
```{r, echo = T}
autoplot(tFilter %on% smaller[[1]], "FL1-H","FL2-H")
```
<!-- ## ----loadData------------------------------------------------------------ -->
<!-- ```{r, echo = T} -->
<!-- library(flowWorkspace) -->
<!-- fcsfiles <- list.files(pattern = "CytoTrol" -->
<!--                        , system.file("extdata", package = "flowWorkspaceData") -->
<!--                        , full = TRUE) -->
<!-- fs <- read.flowSet(fcsfiles) -->
<!-- ``` -->

<!-- ## ----createGatingSet----------------------------------------------------- -->
<!-- ```{r, echo = T} -->
<!-- gs <- GatingSet(fs) -->
<!-- gs -->
<!-- ``` -->
<!-- ## ----getComp -->
<!-- ```{r, echo = T} -->
<!-- gs_manual <- load_gs(list.files(pattern = "gs_manual" -->
<!--                                 , system.file("extdata", package = "flowWorkspaceData") -->
<!--                                 , full = TRUE)) -->
<!-- comp <- getCompensationMatrices(gs_manual[[1]]) -->
<!-- ``` -->
<!-- ## ----Compensate---------------------------------------------------------- -->
<!-- ```{r, echo = T} -->
<!-- comp -->
<!-- gs <- compensate(gs, comp) -->
<!-- ``` -->
<!-- ## ----plotComp -->
<!-- ```{r, echo = T} -->
<!-- fs_comp <- getData(gs) -->
<!-- transList <- estimateLogicle(fs[[1]], c("V545-A","V450-A")) -->
<!-- library(gridExtra) -->
<!-- p1 <- autoplot(transform(fs[[1]], transList) -->
<!--                , 'V545-A', 'V450-A') + ggtitle("Before") -->
<!-- p2 <- autoplot(transform(fs_comp[[1]], transList) -->
<!--                , 'V545-A', 'V450-A') + ggtitle("After") -->
<!-- grid.arrange(as.ggplot(p1), as.ggplot(p2), ncol = 2) -->
<!-- ``` -->
<!-- ## ----nodes--------------------------------------------------------------- -->
<!-- ```{r, echo = T} -->
<!-- getNodes(gs) -->
<!-- ``` -->
<!-- ## ----addTrans------------------------------------------------------------ -->
<!-- ```{r, echo = T} -->
<!-- biexpTrans <- flowJo_biexp_trans(channelRange=4096, maxValue=262144 -->
<!--                           , pos=4.5,neg=0, widthBasis=-10) -->
<!-- chnls <- parameters(comp) -->
<!-- tf <- transformerList(chnls, biexpTrans) -->
<!-- ``` -->
<!-- ## -->
<!-- ```{r, echo = T} -->
<!-- gs <- transform(gs, tf) -->
<!-- ``` -->
<!-- ## ----plotTrans -->
<!-- ```{r, echo = T} -->
<!-- p1 <- autoplot(fs_comp[[1]], "B710-A") + ggtitle("raw") -->
<!-- p2 <- autoplot(flowData(gs)[[1]], "B710-A") +  -->
<!--           ggtitle("trans") +  -->
<!--           ggcyto_par_set(limits = "instrument") -->
<!-- grid.arrange(as.ggplot(p1), as.ggplot(p2), ncol = 2) -->
<!-- ``` -->
<!-- ## ----addGate-nonDebris--------------------------------------------------- -->
<!-- ```{r, echo = T} -->
<!-- rg1 <- rectangleGate("FSC-A"=c(50000, Inf), filterId="NonDebris") -->
<!-- add(gs, rg1, parent = "root") -->
<!-- getNodes(gs) -->
<!-- # gate the data -->
<!-- recompute(gs) -->
<!-- ``` -->
<!-- ## ----plotGate -->
<!-- ```{r, echo = T} -->
<!-- autoplot(gs, "NonDebris") -->
<!-- ``` -->
<!-- ## ----plotGate-density -->
<!-- ```{r, echo = T} -->
<!-- ggcyto(gs, aes(x = `FSC-A`)) + geom_density() + geom_gate("NonDebris") -->
<!-- ``` -->
<!-- ## ----getStats1----------------------------------------------------------- -->
<!-- ```{r, echo = T} -->
<!-- getTotal(gs[[1]], "NonDebris")#counts -->
<!-- getProp(gs[[1]], "NonDebris")#proportion -->
<!-- ``` -->
<!-- ## ----addGate-singlets---------------------------------------------------- -->
<!-- ```{r, echo = T} -->
<!-- mat <- matrix(c(54272,59392,259071.99382782 -->
<!--                 ,255999.994277954,62464,43008,70656 -->
<!--                 ,234495.997428894,169983.997344971,34816) -->
<!--               , nrow = 5) -->
<!-- colnames(mat) <-c("FSC-A", "FSC-H") -->
<!-- mat -->
<!-- pg <- polygonGate(mat) -->
<!-- add(gs, pg, parent = "NonDebris", name = "singlets") -->
<!-- ``` -->

<!-- ## add the third gate -->
<!-- ```{r, echo = T} -->
<!-- rg2 <- rectangleGate("V450-A"=c(2000, Inf)) -->
<!-- add(gs, rg2, parent = "singlets", name = "CD3") -->
<!-- getNodes(gs) -->
<!-- ``` -->

<!-- ## ----addQuadGate--------------------------------------------------------- -->
<!-- ```{r, echo = T} -->
<!-- qg <- quadGate("B710-A" = 2000, "R780-A" = 3000) -->
<!-- add(gs, qg, parent="CD3", names = c("CD8", "DPT", "CD4", "DNT")) -->
<!-- getChildren(gs[[1]], "CD3") -->
<!-- # gate the data from "singlets" -->
<!-- recompute(gs, "singlets") -->
<!-- ``` -->
<!-- ## ----plotgs -->
<!-- ```{r, echo = T} -->
<!-- plot(gs) -->
<!-- ``` -->

<!-- ## ----plotwfdo -->
<!-- ```{r, echo = T} -->
<!-- if(suppressWarnings(require(Rgraphviz))){ -->
<!--     plot(gs) -->
<!-- }else{ -->
<!--     plot(1,1, type="n", axes=FALSE, ann=FALSE) -->
<!--     text(1,1,"Need to install Rgraphviz") -->
<!-- } -->
<!-- ``` -->
<!-- ## ----plotGateAll -->
<!-- ```{r, echo = T} -->
<!-- autoplot(gs[[1]]) -->
<!-- ``` -->
<!-- ## ----getData------------------------------------------------------------- -->
<!-- ```{r, echo = T} -->
<!-- fs_nonDebris <- getData(gs, "NonDebris") -->
<!-- fs_nonDebris  -->
<!-- nrow(fs_nonDebris[[1]]) -->
<!-- nrow(fs[[1]]) -->
<!-- ``` -->
<!-- ## ----getStats2----------------------------------------------------------- -->
<!-- ```{r, echo = T} -->
<!-- getPopStats(gs) -->
<!-- ``` -->
<!-- ## ----Rm------------------------------------------------------------------ -->
<!-- ```{r, echo = T} -->
<!-- Rm('CD3', gs) -->
<!-- getNodes(gs) -->
<!-- Rm('NonDebris', gs) -->
<!-- getNodes(gs) -->
<!-- ``` -->
<!-- ## ----openCyto-nonDebris-------------------------------------------------- -->
<!-- ```{r, echo = T} -->
<!-- library(openCyto) -->
<!-- thisData <- getData(gs) -->
<!-- nonDebris_gate <- fsApply(thisData -->
<!--                           , function(fr) -->
<!--                             openCyto:::.mindensity(fr, channels = "FSC-A")) -->
<!-- add(gs, nonDebris_gate, parent = "root", name = "nonDebris") -->
<!-- recompute(gs) -->
<!-- ``` -->
<!-- ## ----openCyto-singletGate------------------------------------------------ -->
<!-- ```{r, echo = T} -->
<!-- thisData <- getData(gs, "nonDebris") #get parent data -->
<!-- singlet_gate <- fsApply(thisData -->
<!--                         , function(fr) -->
<!--                           openCyto:::.singletGate(fr, channels =c("FSC-A", "FSC-H"))) -->
<!-- add(gs, singlet_gate, parent = "nonDebris", name = "singlets") -->
<!-- recompute(gs) -->
<!-- ``` -->
<!-- ## ----openCyto-CD3-------------------------------------------------------- -->
<!-- ```{r, echo = T} -->
<!-- thisData <- getData(gs, "singlets") #get parent data -->
<!-- CD3_gate <- fsApply(thisData -->
<!--                     , function(fr) -->
<!--                         openCyto:::.mindensity(fr, channels ="V450-A")) -->
<!-- add(gs, CD3_gate, parent = "singlets", name = "CD3") -->
<!-- recompute(gs) -->
<!-- ``` -->
<!-- ## ----openCyto-Tsub------------------------------------------------------- -->
<!-- ```{r, echo = T} -->
<!-- thisData <- getData(gs, "CD3") #get parent data -->
<!-- Tsub_gate <- fsApply(thisData -->
<!--                      , function(fr) -->
<!--                         openCyto::quadGate.seq(fr -->
<!--                              , channels = c("B710-A", "R780-A") -->
<!--                              , gFunc = 'mindensity' -->
<!--                             ) -->
<!--                   ) -->
<!-- add(gs, Tsub_gate, parent = "CD3", names = c("CD8", "DPT", "CD4", "DNT")) -->
<!-- recompute(gs) -->
<!-- ``` -->
<!-- ## ----plotALL-openCyto -->
<!-- ```{r, echo = T} -->
<!-- autoplot(gs[[1]]) -->
<!-- ``` -->
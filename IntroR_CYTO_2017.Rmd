---
title: "Introduction to R"
author: "Brian Capaldo"
date: "Saturday June 10, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data structures

R offers a variety of built-in data structures.

### Base types

The base types include `double`, `integer`, `characater` and `logical`.  Values can be tested as belonging to one of those types.

```{r, eval=F}
typeof(1)
## [1] "double"
typeof(1L)
## [1] "integer"
is.numeric(1.1)
## [1] TRUE
is.logical(TRUE)
is.character("Hello")
```
Every base type has a sentinel value used to represent missing observations.

```{r,eval=F}
x <- 1
x[2] <- NA
typeof(x[2])
## "double"
typeof(NA)
## logical
typeof(NA + 1L)
```

### Vectors

R provides several kinds of compound data structures commonly referred to as *vectors*.  All operations in R are *vectorized*, this means that they take vectors as arguments and they will operate on the individual values (basic types) of these vectors.

```{r}
x <- c(1,2,2)
y <- c(2,2,1)
( x + y ) * x
```

All vectors can be accessed used subsetting operators `[` and `[[`, and can be used with functions `typeof()` (to find out what basic type is in the vector),
`length()` (how many elements are in it), `attributes()` (query the vector's meta data).

#### Atomic vectors

Atomic vectors are homogeneous (possibly multi-dimensional) data structures.

```{r}
c(1,2,3)
c("one","two","three")
```

Element of vectors can be accessed individually.

```{r}
x <- c(1L, 2L, 3L)
x[1] <- 45
x[1]
```

The operator `[<-` is the assignment function.

A two dimensional atomic vector is called a *matrix* and higher-dimensional vector is called an *array*.

```{r}
a <- matrix(1:6, ncol = 3, nrow = 2)
b <- array(1:12, c(2,3,4))
a
b
```

Matrices and array, like vectors, are homogeneous, but it is possible to assign values of different basic types into any one of them. This causes a *coercion* of the entire data structure.

```{r}
x[[1]] <-1.1
x
a[[2,1]] <- "one"
a
```

Coercions go from least to most flexible:  logical, integer, double and character.

R has a powerful set of subsetting operations that apply to all vectors uniformly. R allows, to subset ranges, rows, columns of vectors.

```{r}
a[1,]
a[1:2,]
a[1:2,2:3]
aa <- as.integer(a)
dim(aa) <- c(2,3)
a[1, a[1,] > 1]
aa[1, aa[1,] > 1]
```

When using a predicate such as `a[1,] > 1` for subsetting, behind the scenes R generates a vector of logical values. True indicates a position that should be extracted.  So this is:

```{r}
aa[1,]>1
```

We can use logical arrays to subset as follows:

```{r}
aa[1, c(FALSE, TRUE, TRUE)]
```

Subsetting can be used in assignment operations as well.

```{r}
a[1:3] <- a[4:6]
```


#### Lists

Lists are heterogeneous vectors. The elements of list can be of any kind, including lists and vectors.

```{r}
list(1, "hi", c(1,2))
```

The `typeof()` a list is `list`. You can test for a list with `is.list()` and coerce to a list with `as.list()`. You can turn a list into an atomic vector with `unlist()`. If the elements of a list have different types, `unlist()` will coerce.

### Referential transparency

To facilitate equational reasoning, R attempts to provide *referential transparency* for function calls. Referential transparency means that arguments are not changed by the function being called. So the following function `f(x)` does not modify the vector passed in.

```{r}
x
f <- function(x) { x[1] <- 1 }
f(x)
x
```
